scope: test_cluster_pgcl # Название кластера маленькми буквами. Постфикс _pgcl желательно
name: 192.168.2.11 # Полное название сервера маленькими буквами

# параметры для REST API, который используется для управления Patroni
restapi:
  listen: "192.168.2.11:8008"
  connect_address: "192.168.2.11:8008"
  authentication:
    username: restpatroni
    password: 123

# параметры для raft (распределенного хранилища парамеров Patroni и PostgreSQL для нод кластера)
raft:
  data_dir: /pg_data/raft # директория для хранения информации
  self_addr: "192.168.2.11:5010" # текущая нода кластера
  partner_addrs: # другие ноды кластера
  - 192.168.2.12:5010
  - 192.168.2.13:5010

bootstrap: # Конфигурация начальной загрузки при создании кластера
  dcs: # Параметры, хранящиеся в распределенном хранилище конфигурации
    ttl: 30 # Время жизни ключа лидера (в секундах) в DCS, после этого срока начнется поиск нового мастера
    loop_wait: 10 # Время цикла обработки событий Patroni (в секундах), когда он проверяет свою роль, смотрит какие действия ему, возможно, необходимо выполнить
    retry_timeout: 10 # Время для попыток соединения с DCS и PostgreSQL (в секундах), когда он пытается соединиться с сервисами
    maximum_lag_on_failover: 1048576 # Максимальное количество байтов, на которое может отставать реплика
    postgresql: # Параметры постгреса, общие для всех нод
      use_pg_rewind: true # использовать rewind для восстановления реплики
      use_slots: true # следует ли использовать слоты репликации
      parameters: # Параметры, общие для всего кластера
        archive_mode: 'always' # Полные сегменты WAL передаются в хранилище архива командой archive_command
        archive_timeout: 15min # Время принудительного переключения WAL
        autovacuum: on # Включение автоочистки (подробнее https://habr.com/ru/post/501516/)
        autovacuum_analyze_scale_factor: 0.02 # Процент изменений от размера таблицы для срабатывания команды ANALYZE
        autovacuum_max_workers: 5 # Максимальное число процессов автоочистки
        autovacuum_naptime: 1s # Мминимальная задержка между двумя запусками автоочистки
        autovacuum_vacuum_cost_delay: 20 #  В течение этого времени будет простаивать процесс, превысивший предел стоимости (мс)
        autovacuum_vacuum_cost_limit: 200 # Сумма стоимости обработанных блоков, при накоплении которой процесс очистки будет засыпать
        autovacuum_vacuum_scale_factor: 0.05 # Процент изменений от размера таблицы для срабатывания команды VACUUM
        checkpoint_completion_target: 0.9 # Целевое время для завершения процедуры контрольной точки в процентах от archive_timeout
        hot_standby: 'on' # Можно ли будет подключаться к серверу и выполнять запросы в процессе восстановления
        huge_pages: try # Будет пытаться запрашивать Huge Pages для основной области общей памяти.
        log_autovacuum_min_duration: 0 # Журналировать все действия автоочистки
        log_checkpoints: 'on' #  Протоколирование выполнения контрольных точек и точек перезапуска сервера
        log_connections: 'on' #  Протоколирование всех попыток подключения к серверу
        log_disconnections: 'on' # Протоколирование завершения сеанса
        log_line_prefix: '%t [%p]: [%l-1] %c %x %d %u %a %h ' # 
        log_lock_waits: 'on' # Строка в стиле функции printf, которая выводится в начале каждой строки журнала сообщений
        log_min_duration_statement: 500 # Протоколирование продолжительности выполнения всех команд, время работы которых не меньше указанного (мс)
        log_statement: ddl # Записывает в журнал все команды определения данных, такие как CREATE, ALTER, DROP
        log_temp_files: 0 # Регистрирует в журнале имена и размеры всех временных файлов
        logging_collector: on # Включает сборщик сообщений в журнальные файлы
        max_connections: 1000 # Определяет максимальное число одновременных подключений к серверу БД
        max_replication_slots: 10 # Задаёт максимальное число слотов репликации
        max_wal_senders: 10 # Задаёт максимально допустимое число одновременных подключений ведомых серверов или клиентов потокового копирования
        max_wal_size: 4GB # Задает размер сгенерированных WAL для автоматического выполнения контрольной точки, если не прошло вермя archive_timeout
        min_wal_size: 2GB # Не удалять старые файлы WAL, пока все WAL занимают на диске меньше wal_buffers * wal_keep_segments + min_wal_size во время выполнения контрольной точки
        password_encryption: 'scram-sha-256'
        pg_stat_statements.max: 5000 # Максимальное число операторов, отслеживаемых pg_stat_statements
        pg_stat_statements.save: off # Сохранять статистику операторов сохраняться после перезагрузки сервера
        pg_stat_statements.track: top #  Отслеживають операторы верхнего уровня (те, что непосредственно выполняются клиентами)
        shared_preload_libraries: dblink,pg_stat_statements # Библиотеки, которые будут загружаться при запуске сервера
        superuser_reserved_connections: 5 # Количество «слотов» подключений, зарезервированных для суперпользователей
        tcp_keepalives_idle: 900 # Период отсутствия сетевой активности, по истечении которого операционная система должна отправить клиенту TCP-сигнал сохранения соединения
        tcp_keepalives_interval: 100 # Интервал, по истечении которого следует повторять TCP-сигнал сохранения соединения, если от клиента не получено подтверждение предыдущего сигнала
        track_activities: on # Включает сбор сведений о текущих командах, выполняющихся во всех сеансах
        track_counts: on # Сбор статистики активности в базе данных
        track_functions: all # Подсчёт вызовов функций и времени их выполнения на языке PL, SQL, C
        track_io_timing: on # По умолчанию параметр отключён, поскольку инициирует постоянный запрос текущего времени у OS, что может значительно замедлить работу на некоторых платформах
        wal_buffers: 16MB # Объём разделяемой памяти, который будет использоваться для буферизации данных WAL = размер одного WAL файла
        wal_keep_segments: 1000 # Минимальное число файлов WAL, которые будут сохраняться в каталоге pg_wal
        wal_level: replica #  WAL включает данные, необходимые для поддержки архивирования WAL и репликации
        wal_log_hints: 'on' # Записывать в WAL всё содержимое каждой страницы при первом изменении этой страницы после контрольной точки
  initdb: # Параметры, указывающиеся при инициализации кластера
  - encoding: UTF8 # Кодировка по умолчанию для кластера 
  - data-checksums # Применять контрольные суммы на страницах данных
  - locale: en_US.UTF8 # Локаль кластера по умолчанию
  pg_hba: # Список строк разрешающих подключение для динамической конфигурации
  - local all postgres peer # Разрешать подключение c локального хоста только под УЗ postgres
  - host replication replicator 127.0.0.1/32 md5 # Разрешать подключение репликации с локального хоста с паролем
  - host replication replicator ::1/128 md5 # Разрешать подключение репликации с локального хоста с паролем
  - host replication replicator 192.168.2.11/mask md5 # Разрешать подключение репликации с реплики с паролем
  - host replication replicator 192.168.2.12/mask md5 # Разрешать подключение репликации с реплики с паролем
  - host replication replicator 192.168.2.13/mask md5 # Разрешать подключение репликации с реплики с паролем
  - host all all 10.0.0.0/0 md5 #  Разрешать подключение из сети 10.0.0.0/0 с паролем

postgresql: # Параметры PostgreSQL, которые не требуют одинаковых значений между мастером и всеми репликами
  listen: 0.0.0.0:5432 # IP-адрес + порт, который слушает PostgreSQL для потоковой репликации
  connect_address: 0.0.0.0:5432 # IP-адрес + порт, через который PostgreSQL доступен для других узлов и приложений
  data_dir: /pg_data/test_cluster_pgcl/14 # Расположение каталога данных Postgres
  bin_dir: /usr/pgsql-14/bin # Путь к двоичным файлам PostgreSQL
  pgpass: /home/postgres/.pgpass # Путь к файлу паролей .pgpass для pg_basebackup, post_init и т.д.
  authentication: # Роли для подключения Patroni
    replication: # Для подключения реплик
      username: replicator # предлагается единое наименование replicator
      password: 123456
    superuser: # Для суперпользователя
      username: postgres
      password: 123456
  parameters: # Парамеры записываются в postgresql.conf
    # для подбора начальных настроек можно использовать
    # https://pgtune.leopard.in.ua/#/
    # http://pgconfigurator.cybertec.at/
    # https://interface31.ru/tech_it/2020/03/optimizaciya-proizvoditel-nosti-postgresql-dlya-raboty-s-1spredpriyatie.html
    shared_buffers: 25GB # RAM/4 - объём памяти, который будет использовать сервер баз данных для буферов в разделяемой памяти
    effective_cache_size: 75GB # RAM - shared_buffers - определяет представление планировщика об эффективном размере дискового кеша, доступном для одного запроса
    work_mem: 32MB # RAM/4..16/max_connections - максимальный объём памяти, который будет использоваться во внутренних операциях при обработке запросов пользователей
    maintenance_work_mem: 2GB # RAM/16..48 или work_mem * 4 - максимальный объём памяти, который будет использоваться во внутренних операциях при обработке запросов рабочих процессов
    archive_command: /bin/true # - Это для нод без бекапа. Для нод с РК смотри инструкцию по настройке бекапа.
    log_destination: csvlog # Протоколирование ведётся в формате CSV
    log_directory: pg_log # Каталог, в котором создаются журнальные файлы (относительно data_dir)
    log_file_mode: '0644' # - Права доступа к журнальным файлам
    log_filename: 'postgresql-%d.log' # - Имена журнальных файлов (день недели как десятичное число [1,7], где 1 - понедельник)
    log_min_messages: info # В логи пишется не большой объем неявно запрошенной пользователем информации + log_* события
    log_rotation_age: 1d # Определяет максимальное время переключения отдельного журнального файла (log_filename + log_rotation_age - логи хранятся неделю)
    log_rotation_size: 0 # Смена файлов по размеру не производится
    log_truncate_on_rotation: on # Перезаписывать существующие журнальные файлы
    stats_temp_directory: '/pg_data/ramdisk/pg_stat_tmp' # Где будут храниться временные данные статистики - wiki: Перенос счетчиков статистики PostgreSQL в ОЗУ
    unix_socket_directories: '/var/run/postgresql' # Задаёт каталог Unix-сокета, через который сервер будет принимать подключения клиентских приложений
  use_unix_socket: true # Patroni должен предпочесть использовать сокеты unix для подключения к кластеру
  pg_hba: # Список строк, которые будут добавляться в pg_hba.conf при старте patroni
  - local all postgres peer # Разрешать подключение c локального хоста только под УЗ postgres
  - host replication replicator 127.0.0.1/32 md5 # Разрешать подключение репликации с локального хоста с паролем
  - host replication replicator ::1/128 md5 # Разрешать подключение репликации с локального хоста с паролем
  - host replication replicator 192.168.2.11/mask md5 # Разрешать подключение репликации с реплики с паролем
  - host replication replicator 192.168.2.12/mask md5 # Разрешать подключение репликации с реплики с паролем
  - host replication replicator 192.168.2.13/mask md5 # Разрешать подключение репликации с реплики с паролем
  - host all all 10.0.0.0/0 md5 #  Разрешать подключение из сети 10.0.0.0/0 с паролем

tags:
  nofailover: false # разрешено ли этому узлу участвовать в гонке лидеров
  noloadbalance: false # будет ли исключен из балансировки нагрузки
  clonefrom: false # приоритет при клонировать реплики с этой ноды
  nosync: false # не подключать ноду как синхронную реплику

log: # Параметры логов Patroni
  dir: /pg_log/patroni # Куда писать логи
  level: INFO # Уровень логирования
